<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        // 给你一个字符串 croakOfFrogs，它表示不同青蛙发出的蛙鸣声（字符串 "croak" ）的组合。
        // 由于同一时间可以有多只青蛙呱呱作响，所以 croakOfFrogs 中会混合多个 “croak” 。

        // 请你返回模拟字符串中所有蛙鸣所需不同青蛙的最少数目。

        // 要想发出蛙鸣 "croak"，青蛙必须 依序 输出 ‘c’, ’r’, ’o’, ’a’, ’k’ 这 5 个字母。
        // 如果没有输出全部五个字母，那么它就不会发出声音。如果字符串 croakOfFrogs 不是由若干有效的 "croak" 字符混合而成，请返回 -1 。

        //  

        // 示例 1：

        // 输入：croakOfFrogs = "croakcroak"
        // 输出：1 
        // 解释：一只青蛙 “呱呱” 两次
        // 示例 2：

        // 输入：croakOfFrogs = "crcoakroak"
        // 输出：2 
        // 解释：最少需要两只青蛙，“呱呱” 声用黑体标注
        // 第一只青蛙 "crcoakroak"
        // 第二只青蛙 "crcoakroak"
        // 示例 3：

        // 输入：croakOfFrogs = "croakcrook"
        // 输出：-1
        // 解释：给出的字符串不是 "croak" 的有效组合。
        //  

        // 提示：

        // 1 <= croakOfFrogs.length <= 105
        // 字符串中的字符只有 'c', 'r', 'o', 'a' 或者 'k'

        // 来源：力扣（LeetCode）
        // 链接：https://leetcode.cn/problems/minimum-number-of-frogs-croaking
        // 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

        /**
         * @param {string} croakOfFrogs
         * @return {number}
         * 超时了
         */
        // var minNumberOfFrogs = function (croakOfFrogs) {
        //     let ans = 0
        //     const arr = []
        //     let map = new Map([['c', 'r'], ['r', 'o'], ['o', 'a'], ['a', 'k']])
        //     for (let i = 0; i < croakOfFrogs.length; i++) {
        //         const key = croakOfFrogs[i]
        //         switch (key) {
        //             case 'c':
        //                 arr.push({
        //                     value: 'c',
        //                     need: map.get(key)
        //                 })
        //                 break;
        //             case 'k': {
        //                 let index = arr.findIndex(item => item.need === 'k')
        //                 if (index === -1) return -1
        //                 arr.splice(index, 1)
        //                 break
        //             }
        //             default: {
        //                 let index = arr.findIndex(item => item.need === key)
        //                 if (index === -1)  return -1
        //                 arr[index].value += key
        //                 arr[index].need = map.get(key)
        //                 break;
        //             }
        //         }
        //         ans = Math.max(arr.length, ans)
        //     }
        //     if (arr.length) return -1
        //     return ans
        // };

        /**
         * @param {string} croakOfFrogs
         * @return {number}
         * 官方题解牛逼！
         */
        var minNumberOfFrogs = function (croakOfFrogs) {
            let ans = 0, c = 0, r = 0, o = 0, a = 0, k = 0
            for (let i = 0; i < croakOfFrogs.length; i++) {
                const key = croakOfFrogs[i]
                if (key === 'c') c++
                if (key === 'r') r++
                if (key === 'o') o++
                if (key === 'a') a++
                if (key === 'k') k++
                if (r > c || o > r || a > o || k > a) return -1
                if (k === 1) {
                    c--
                    r--
                    o--
                    a--
                    k--
                }
                ans = Math.max(c, ans)
            }
            if (c + r + o + a + k > 0) return -1
            return ans
        };
    </script>
</body>

</html>