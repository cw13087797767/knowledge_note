<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        // 给你一个整数数组 nums 和一个整数 k。如果某个连续子数组中恰好有 k 个奇数数字，我们就认为这个子数组是「优美子数组」。

        // 请返回这个数组中 「优美子数组」 的数目。

        //  

        // 示例 1：

        // 输入：nums = [1,1,2,1,1], k = 3
        // 输出：2
        // 解释：包含 3 个奇数的子数组是 [1,1,2,1] 和 [1,2,1,1] 。
        // 示例 2：

        // 输入：nums = [2,4,6], k = 1
        // 输出：0
        // 解释：数列中不包含任何奇数，所以不存在优美子数组。
        // 示例 3：

        // 输入：nums = [2,2,2,1,2,2,1,2,2,2], k = 2
        // 输出：16
        //  

        // 提示：

        // 1 <= nums.length <= 50000
        // 1 <= nums[i] <= 10^5
        // 1 <= k <= nums.length

        // 来源：力扣（LeetCode）
        // 链接：https://leetcode.cn/problems/count-number-of-nice-subarrays
        // 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

        /**
         * @param {number[]} nums
         * @param {number} k
         * @return {number}
         */
        var numberOfSubarrays = function(nums, k) {
            const indexArr = []
            let ans = 0
            for (let i = 0; i < nums.length; i++) {
                if (nums[i] % 2 === 1) {
                    indexArr.push(i)
                }
            }
            if (indexArr.length < k) return ans
            for (let i = 0; i <= indexArr.length - k; i++) {
                const leftNum = Math.abs(indexArr[i] === 0 ? 0 : indexArr[i - 1] !== undefined ? indexArr[i] - indexArr[i - 1] - 1 : indexArr[i])
                const rightNum = Math.abs(indexArr[i + k - 1] === nums.length - 1 ? 0 : (indexArr[i + k] !== undefined ? indexArr[i + k] - indexArr[i + k - 1] - 1 : nums.length - indexArr[i + k - 1] - 1))
                ans = ans + 1 + leftNum + rightNum + leftNum * rightNum
            }
            return ans
        };
    </script>
</body>
</html>