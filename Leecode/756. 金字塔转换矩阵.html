<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        // 现在，我们用一些方块来堆砌一个金字塔。 每个方块用仅包含一个字母的字符串表示。

        // 使用三元组表示金字塔的堆砌规则如下：

        // 对于三元组 ABC ，C 为顶层方块，方块 A 、B 分别作为方块 C 下一层的的左、右子块。当且仅当 ABC 是被允许的三元组，我们才可以将其堆砌上。

        // 初始时，给定金字塔的基层 bottom，用一个字符串表示。一个允许的三元组列表 allowed，每个三元组用一个长度为 3 的字符串表示。

        // 如果可以由基层一直堆到塔尖就返回 true ，否则返回 false 。

        //  

        // 示例 1：

        // 输入：bottom = "BCD", allowed = ["BCG", "CDE", "GEA", "FFF"]
        // 输出：true
        // 解释：
        // 可以堆砌成这样的金字塔:
        //     A
        // / \
        // G   E
        // / \ / \
        // B   C   D

        // 因为符合 BCG、CDE 和 GEA 三种规则。
        // 示例 2：

        // 输入：bottom = "AABA", allowed = ["AAA", "AAB", "ABA", "ABB", "BAC"]
        // 输出：false
        // 解释：
        // 无法一直堆到塔尖。
        // 注意, 允许存在像 ABC 和 ABD 这样的三元组，其中 C != D。
        //  

        // 提示：

        // bottom 的长度范围在 [2, 8]。
        // allowed 的长度范围在[0, 200]。
        // 方块的标记字母范围为{'A', 'B', 'C', 'D', 'E', 'F', 'G'}。

        /**
         * @param {string} bottom
         * @param {string[]} allowed
         * @return {boolean}
         */
        var pyramidTransition = function(bottom, allowed) {


            // 错误答案 做不出来

            // const len = bottom.length
            // const dp = new Array(len).fill(0).map(() => [])
            // dp[0] = bottom.split('').map(a => [a])
            // let i = 0
            // while (i < dp.length) {
            //     for (let j = 1; j < dp[i].length; j++) {
            //         const item1 = dp[i][j - 1], item2 = dp[i][j]
            //         for (let x = 0; x < item1.length; x++) {
            //             for (let y = 0; y < item2.length; y++) {
            //                 for (let z = 0; z < allowed.length; z++) {
            //                     const str = item1[x] + item2[y]
            //                     if (allowed[z].startsWith(str)) {
            //                         if (!dp[i + 1][j - 1]) {
            //                             dp[i + 1][j - 1] = []
            //                         }
            //                         dp[i + 1][j - 1].push(allowed[z][2])
            //                     }
            //                 }
            //             }
            //         }
            //     }
            //     ++i
            // }
            // return dp[len - 1].length > 0
        };
    </script>
</body>
</html>