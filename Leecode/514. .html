<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
        <!-- 电子游戏“辐射4”中，任务“通向自由”要求玩家到达名为“Freedom Trail Ring”的金属表盘，并使用表盘拼写特定关键词才能开门。

        给定一个字符串 ring，表示刻在外环上的编码；给定另一个字符串 key，表示需要拼写的关键词。您需要算出能够拼写关键词中所有字符的最少步数。

        最初，ring 的第一个字符与12:00方向对齐。您需要顺时针或逆时针旋转 ring 以使 key 的一个字符在 12:00 方向对齐，然后按下中心按钮，以此逐个拼写完 key 中的所有字符。

        旋转 ring 拼出 key 字符 key[i] 的阶段中：

        您可以将 ring 顺时针或逆时针旋转一个位置，计为1步。旋转的最终目的是将字符串 ring 的一个字符与 12:00 方向对齐，并且这个字符必须等于字符 key[i] 。
        如果字符 key[i] 已经对齐到12:00方向，您需要按下中心按钮进行拼写，这也将算作 1 步。按完之后，您可以开始拼写 key 的下一个字符（下一阶段）, 直至完成所有拼写。
        示例：

         


         
        输入: ring = "godding", key = "gd"
        输出: 4
        解释:
        对于 key 的第一个字符 'g'，已经在正确的位置, 我们只需要1步来拼写这个字符。 
        对于 key 的第二个字符 'd'，我们需要逆时针旋转 ring "godding" 2步使它变成 "ddinggo"。
        当然, 我们还需要1步进行拼写。
        因此最终的输出是 4。
        提示：

        ring 和 key 的字符串长度取值范围均为 1 至 100；
        两个字符串中都只有小写字符，并且均可能存在重复字符；
        字符串 key 一定可以由字符串 ring 旋转拼出。 -->
        
        <script>
            // const findRotateSteps = (ring, key) => {
            //     let index = 0
            //     let count = 0
            //     for (let i = 0; i < key.length; i++) {
            //         let flag = true
            //         let TIndex = index
            //         let FIndex = index
            //         while (flag) {
            //             if (
            //                 ring[getIndex(TIndex,ring.length)] === key[i] 
            //                 || ring[getIndex(FIndex,ring.length)] === key[i]
            //             ) {
            //                 index = ring[getIndex(TIndex,ring.length)] === key[i] ? TIndex : FIndex
            //                 flag = false
            //                 count++
            //             } else {
            //                 TIndex++
            //                 FIndex--
            //                 count++
            //             }
            //         }
            //     }
            //     return count
            // };

            // const getIndex = (index,size) => {
            //     while (index >= size || index < 0) {
            //         index = index >= size ? index - size : index + size
            //     }
            //     return index
            // }

            var findRotateSteps = function (ring, key) {
                const indexMap = {};
                for (let i = 0; i < ring.length; i++) {
                    const c = ring[i];
                    if (indexMap[c]) {
                    indexMap[c].push(i);
                    } else {
                    indexMap[c] = [i];
                    }
                }

                const memo = new Array(ring.length)
                for (let i = 0; i < ring.length; i++) {
                    memo[i] = new Array(key.length).fill(-1)
                }

                const dfs = (ringI, keyI) => {
                    if (keyI == key.length) {
                    return 0;
                    }
                    if (memo[ringI][keyI] != -1) {
                    return memo[ringI][keyI]
                    }
                    const cur = key[keyI];
                    let res = Infinity;
                    for (const targetI of indexMap[cur]) {
                    const d1 = Math.abs(ringI - targetI);
                    const d2 = ring.length - d1;
                    const curMin = Math.min(d1, d2);
                    res = Math.min(res, curMin + dfs(targetI, keyI + 1));
                    }
                    memo[ringI][keyI] = res;
                    return res;
                };

                return key.length + dfs(0, 0);
            };


            console.log(findRotateSteps("nyngl",'yyynnnnnnlllggg'))

            // 不是正解，应该要用动态规划来实现，记录每次旋转后的步数，取最小值
        </script>
</body>
</html>