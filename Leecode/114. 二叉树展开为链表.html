<!--
 * @Description: 
 * @Date: 2022-04-07 10:46:06
 * @LastEditors: cw
 * @LastEditTime: 2022-04-07 11:17:13
 * @FilePath: \knowledge_note\Leecode\114. 二叉树展开为链表.html
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        // 给你二叉树的根结点 root ，请你将它展开为一个单链表：

        // 展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。
        // 展开后的单链表应该与二叉树 先序遍历 顺序相同。
        // 示例 1：

        // 输入：root = [1,2,5,3,4,null,6]
        // 输出：[1,null,2,null,3,null,4,null,5,null,6]
        // 示例 2：

        // 输入：root = []
        // 输出：[]
        // 示例 3：

        // 输入：root = [0]
        // 输出：[0]
        //  

        // 提示：

        // 树中结点数在范围 [0, 2000] 内
        // -100 <= Node.val <= 100

        // 来源：力扣（LeetCode）
        // 链接：https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list
        // 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

        /**
         * Definition for a binary tree node.
         * function TreeNode(val, left, right) {
         *     this.val = (val===undefined ? 0 : val)
         *     this.left = (left===undefined ? null : left)
         *     this.right = (right===undefined ? null : right)
         * }
         */
        
        function TreeNode(val, left, right) {
            this.val = (val===undefined ? 0 : val)
            this.left = (left===undefined ? null : left)
            this.right = (right===undefined ? null : right)
        }

        const r = {
            val:1,
            left:{
                val:2,
                left:{
                    val:3,
                },
                right:{
                    val:4
                }
            },
            right:{
                val:5,
                right:{
                    val:6
                }
            }
        }

        /**
         * @param {TreeNode} root
         * @return {void} Do not return anything, modify root in-place instead.
         */
        var flatten = function(root) {
            const arr = []
            const proorder = tree => {
                if (!tree) return
                arr.push(tree.val)
                proorder(tree.left)
                proorder(tree.right)
            }
            proorder(root)
            arr.shift()
            let tree = root
            while (arr.length) {
                tree.left = null
                const newTreeNode = new TreeNode(arr.shift())
                tree.right = newTreeNode
                tree = newTreeNode

            }
            return root
        };
    </script>
</body>
</html>