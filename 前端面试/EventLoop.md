## Event Loop 

### 参考文章：https://www.ruanyifeng.com/blog/2014/10/event-loop.html

### 什么是Event Loop?
js有一个很大的特点就是单线程，同步任务在主线程上执行，形成一个。异步任务存放在“任务队列”之中，“任务队列”可以是一个事件的队列。每当“执行栈”的同步任务执行完毕后，系统就会去读取“任务队列”。读取里面的任务进入“执行栈”中执行。
主线程从“任务队列”中读取事件，这个过程是循环不断的，所以整个这样一个运行机制被称为事件循环（Event Loop）

### 为什么js是单线程？
单线程指的是同一个时间只能做一件事情，之所以js不能有多个线程，是因为和js的用途有关。js主要功能是与用户的交互，和操作dom等，如果js同时有多个线程在处理一个dom节点，一个添加，另一个删除，则会出现问题。
为了利用CPU的计算能力，HTML5提出了Web Worker标准，允许js脚本创建多个线程，但是子线程完全受主线程控制，并且不得操作dom，所以这个新标准并没有改变js单线程的本质。

### 任务队列
单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。如果排队是因为计算量大，CPU忙不过来，倒也算了，但是很多时候CPU是闲着的，因为IO设备（输入输出设备）很慢（比如Ajax操作从网络读取数据），不得不等着结果出来，再往下执行。JavaScript语言的设计者意识到，这时主线程完全可以不管IO设备，挂起处于等待中的任务，先运行排在后面的任务。等到IO设备返回了结果，再回过头，把挂起的任务继续执行下去。
于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入"任务队列"（task queue）的任务，只有"任务队列"通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。

#### 异步执行的运行机制：
（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。
（2）主线程之外，还存在一个"任务队列"（task queue）。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。
（3）一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。
（4）主线程不断重复上面的第三步。

### 定时器
定时器功能主要由setTimeout()和setInterval()这两个函数来完成，他们内部的运行机制完全一样，区别在于执行一次还是反复执行。
setTimeout接受两个参数，第一个是回调函数，第二个是推迟执行毫秒数。
setTimeout(fn,0)的含义是指某个人物在主流程最早可得的空闲时间执行，也就是尽可能早的执行。他在“任务队列”的尾部添加一个事件。因此要等到同步任务和“任务队列”现有的事情都处理完，才会得到执行。如果同步任务“任务队列”执行代码耗时较长，有可能很久，所以没法保证fn一定会在设定的时间执行。